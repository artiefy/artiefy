Nodemailer
Nodemailer is a module for Node.js applications that allows easy email sending. The project started in 2010 when there were few reliable options for sending email messages, and today, it is the default solution for most Node.js users.

npm install nodemailer
Check out EmailEngine ‚Äì a self-hosted email gateway that allows you to make REST requests to IMAP and SMTP servers. EmailEngine also sends webhooks whenever something changes on the registered accounts.

Using the email accounts registered with EmailEngine, you can receive and send emails. It supports OAuth2, delayed sends, opens and clicks tracking, bounce detection, and more, all without needing an external MTA service.

Nodemailer features
A single module with zero dependencies ‚Äì easy to audit the code with no hidden complexities
Emphasis on security ‚Äì avoid RCE vulnerabilities
Unicode support to use any characters, including emoji üí™
Windows support ‚Äì install with npm on Windows without any compiled dependencies. Perfect for use with Azure or on your local Windows machine
Send HTML content with plain text alternatives
Attach Attachments to emails
Embed Images in HTML emails so your design doesn‚Äôt get blocked
Secure email delivery with TLS/STARTTLS
Various transport methods beyond the default SMTP support
Sign emails with DKIM
Custom Plugin support for advanced message manipulation
Supports OAuth2 authentication
Proxies for SMTP connections
ES6 codebase ‚Äì fewer chances of memory leaks from hoisted var‚Äôs
Autogenerated test email accounts from Ethereal.email
Requirements
Node.js v6.0.0 or newer. That‚Äôs all you need.
If you‚Äôre running Node.js version 6 or later, you can use Nodemailer. There are no specific platform or resource requirements. All Nodemailer methods support both callbacks and Promises (if no callback is provided). If you want to use async..await, you‚Äôll need Node.js v8.0.0 or newer.

TL;DR
To send an email, follow these steps:

Create a Nodemailer transporter using either SMTP or another transport method
Set up your message options (who sends what to whom)
Deliver the message using the sendMail() method of your transporter
Example
Below is an example to send an email with both plain text and HTML content using Ethereal Email.

const nodemailer = require("nodemailer");

const transporter = nodemailer.createTransport({
  host: "smtp.ethereal.email",
  port: 587,
  secure: false, // true for port 465, false for other ports
  auth: {
    user: "maddison53@ethereal.email",
    pass: "jn7jnAPss4f63QBp6D",
  },
});

// async..await is not allowed in global scope, must use a wrapper
async function main() {
  // send mail with defined transport object
  const info = await transporter.sendMail({
    from: '"Maddison Foo Koch üëª" <maddison53@ethereal.email>', // sender address
    to: "bar@example.com, baz@example.com", // list of receivers
    subject: "Hello ‚úî", // Subject line
    text: "Hello world?", // plain text body
    html: "<b>Hello world?</b>", // html body
  });

  console.log("Message sent: %s", info.messageId);
  // Message sent: <d786aa62-4e0a-070a-47ed-0b0666549519@ethereal.email>
}

main().catch(console.error);
Examples
Nodemailer AMQP example: Learn how to use RabbitMQ with Nodemailer for email message management. Source.
Output from the example script viewed through the Ethereal mail catching service:



Source
Find the Nodemailer source code on GitHub.

Nodemailer was created by Andris Reinman, and the Nodemailer logo was designed by Sven Kristjansen.

Usage
Setting it up
Install Nodemailer from npm

npm install nodemailer
To send emails you need a transporter object

let transporter = nodemailer.createTransport(transport[, defaults])
Where

transporter is going to be an object that is able to send mail
transport is the transport configuration object, connection url or a transport plugin instance
defaults is an object that defines default values for mail options
You have to create the transporter object only once. If you already have a transporter object you can use it to send mail as much as you like.
Send using SMTP
See the details about setting up a SMTP based transporter here.

Send using a transport plugin
See the details about setting up a plugin based transporter here.

Sending mail
Once you have a transporter object you can send mail with it:

transporter.sendMail(data[, callback])
Where

data defines the mail content (see Message Configuration for possible options)
callback is an optional callback function to run once the message is delivered or it failed
err is the error object if message failed
info includes the result, the exact format depends on the transport mechanism used
info.messageId most transports should return the final Message-Id value used with this property
info.envelope includes the envelope object for the message
info.accepted is an array returned by SMTP transports (includes recipient addresses that were accepted by the server)
info.rejected is an array returned by SMTP transports (includes recipient addresses that were rejected by the server)
info.pending is an array returned by Direct SMTP transport. Includes recipient addresses that were temporarily rejected together with the server response
response is a string returned by SMTP transports and includes the last SMTP response from the server
If the message includes several recipients then the message is considered sent if at least one recipient is accepted
If callback argument is not set then the method returns a Promise object. Nodemailer itself does not use Promises internally but it wraps the return into a Promise for convenience.
SMTP? Say what?
You might wonder why you would need to set something up while in comparison PHP‚Äôs mail command works out of the box with no special configuration whatsoever. Just call mail(‚Ä¶) and you‚Äôre already sending mail. So what‚Äôs going on in Node.js?

The difference is in the software stack required for your application to work. While Node.js stack is thin, all you need for your app to work is the node binary, then PHP‚Äôs stack is fat. The server you‚Äôre running your PHP code on has several different components installed.

Firstly the PHP interpreter itself. Then there‚Äôs some kind of web server, most probably Apache or Nginx. Web server needs some way to interact with the PHP interpreter, so you have a (fast-)CGI process manager. There might be MySQL also running in the same host. Depending on the installation type you might even have imagemagick executables or other helpers lying around somewhere. And finally, you have the sendmail binary.

What PHP‚Äôs mail() call actually does is that it passes your mail data to sendmail‚Äôs stdin and thats it, no magic involved. sendmail does all the heavy lifting of queueing your message and trying to send it to the recipients' MX mail server.

In fact you can achieve the exact same behavior in Nodemailer as well by using the sendmail transport. The difference being that in case of PHP the sendmail configuration resides in php.ini but in case of Node.js the sendmail configuration is part of Nodemailer setup.

Unfortunately this might not always work ‚Äì as it was already said, the stack for Node.js is thin and this means that sendmail might not have been installed to the server your application is running on. This is why it is better to rely on an actual SMTP service that is always accessible.
Using Gmail
Even though Gmail is the fastest way to get started with sending emails, it is by no means a preferable solution unless you are using OAuth2 authentication. Gmail expects the user to be an actual user not a robot so it runs a lot of heuristics for every login attempt and blocks anything that looks suspicious to defend the user from account hijacking attempts. For example you might run into trouble if your server is in another geographical location ‚Äì everything works in your dev machine but messages are blocked in production.

Additionally Gmail has came up with the concept of ‚ÄúLess Secure‚Äù apps which is basically anyone who uses plain password to login to Gmail, so you might end up in a situation where one username can send mail (support for ‚Äúless secure‚Äù apps is enabled) but other is blocked (support for ‚Äúless secure‚Äù apps is disabled). You can configure your Gmail account to allow less secure apps here. When using this method make sure to also enable the required functionality by completing the ‚ÄúCaptcha Enable‚Äù challenge. Without this, less secure connections probably would not work.

If you are using 2FA you would have to create an ‚ÄúApplication Specific‚Äù password for Nodemailer to work.

Gmail also always sets authenticated username as the From: email address. So if you authenticate as foo@example.com and set bar@example.com as the from: address, then Gmail reverts this and replaces the sender with the authenticated user.

To prevent having login issues you should either use OAuth2 (see details here) or use another delivery provider and preferably a dedicated one. Usually these providers have free plans available that are comparable to the daily sending limits of Gmail. Gmail has a limit of 500 recipients a day (a message with one To and one Cc address counts as two messages since it has two recipients) for @gmail.com addresses and 2000 for Google Apps customers, larger SMTP providers usually offer about 200-300 recipients a day for free.

Delivering bulk mail
Here are some tips how to handle bulk mail, for example if you need to send 10 million messages at once.

Use a dedicated delivery provider. Do not use services that offer SMTP as a sideline or for free (that‚Äôs Gmail or the SMTP of your homepage hosting company) to send bulk mail ‚Äì you‚Äôll hit all the hard limits immediately or get labelled as spammer. Basically you get what you pay for and if you pay zero then your deliverability is near zero as well. Email might seem free but it is only free to a certain amount and that amount certainly does not include 10 million emails in a short period of time.
Use a dedicated queue manager, for example RabbitMQ for queueing the emails. Nodemailer creates a callback function with related scopes etc. for every message so it might be hard on memory if you pile up the data for 10 million messages at once. Better to take the data from a queue when there‚Äôs a free spot in the connection pool (previously sent message returns its callback).
Use pooled SMTP by setting pool option to true (assuming you always send using the same credentials). You do not want to have the overhead of creating a new connection and doing the SMTP handshake dance for every single email. Pooled connections make it possible to bring this overhead to a minimum.
Set maxMessages option to Infinity for the pooled SMTP transport. Dedicated SMTP providers happily accept all your emails as long you are paying for these, so no need to disconnect in the middle if everything is going smoothly. The default value is 100 which means that once a connection is used to send 100 messages it is removed from the pool and a new connection is created.
Set maxConnections to whatever your system can handle. There might be limits to this on the receiving side, so do not set it to Infinity, even 20 is probably much better than the default 5. A larger number means a larger amount of messages are sent in parallel.
Use file paths not URLs for attachments. If you are reading the same file from the disk several million times, the contents for the file probably get cached somewhere between your app and the physical hard disk, so you get your files back quicker (assuming you send the same attachment to all recipients). There is nothing like this for URLs ‚Äì every new message makes a fresh HTTP fetch to receive the file from the server.
If the SMTP service accepts HTTP API as well you still might prefer SMTP and not the HTTP API as HTTP introduces additional overhead. You probably want to use HTTP over SMTP if the HTTP API is bulk aware ‚Äì you send a message template and the list of 10 million recipients and the service compiles this information into emails itself, you can‚Äôt beat this with SMTP.
Message configuration
The following are the possible fields of an email message:

Common fields
from - The email address of the sender. All email addresses can be plain ‚Äòsender@server.com‚Äô or formatted '‚ÄúSender Name‚Äù sender@server.com', see Address object for details
to - Comma separated list or an array of recipients email addresses that will appear on the To: field
cc - Comma separated list or an array of recipients email addresses that will appear on the Cc: field
bcc - Comma separated list or an array of recipients email addresses that will appear on the Bcc: field
subject - The subject of the email
text - The plaintext version of the message as an Unicode string, Buffer, Stream or an attachment-like object ({path: ‚Äò/var/data/‚Ä¶'})
html - The HTML version of the message as an Unicode string, Buffer, Stream or an attachment-like object ({path: ‚Äòhttp://‚Ä¶'})
attachments - An array of attachment objects (see Using attachments for details). Attachments can be used for embedding images as well.
A large majority of emails sent look a lot like this, using only a few basic fields:

var message = {
  from: "sender@server.com",
  to: "receiver@sender.com",
  subject: "Message title",
  text: "Plaintext version of the message",
  html: "<p>HTML version of the message</p>",
};
All text fields (email addresses, plaintext body, html body, attachment filenames) use UTF-8 as the encoding. Attachments are streamed as binary.
More advanced fields
Routing options
sender - An email address that will appear on the Sender: field (always prefer from if you‚Äôre not sure which one to use)
replyTo - An email address that will appear on the Reply-To: field
inReplyTo - The Message-ID this message is replying to
references - Message-ID list (an array or space separated string)
envelope - optional SMTP envelope, if auto generated envelope is not suitable (see SMTP envelope for details)
Content options
attachDataUrls ‚Äì if true then convert data: images in the HTML content of this message to embedded attachments
watchHtml - Apple Watch specific HTML version of the message. Latest watches have no problems rendering text/html content so watchHtml is most probably never seen by the recipient
amp - AMP4EMAIL specific HTML version of the message, same usage as with text and html. See AMP example below for usage or this blogpost for sending and rendering
When using `amp` then make sure it is a full and valid AMP4EMAIL document, otherwise the displaying email client most probably falls back to `html` and ignores the `amp` part. Validate your AMP4EMAIL content [here](https://validator.ampproject.org/#htmlFormat=AMP4EMAIL)
icalEvent ‚Äì iCalendar event to use as an alternative. See details here
alternatives - An array of alternative text contents (in addition to text and html parts) (see Using alternative content for details)
encoding - identifies encoding for text/html strings (defaults to ‚Äòutf-8‚Äô, other values are ‚Äòhex‚Äô and ‚Äòbase64‚Äô)
raw - existing MIME message to use instead of generating a new one. See details here
textEncoding - force content-transfer-encoding for text values (either quoted-printable or base64). By default the best option is detected (for lots of ascii use quoted-printable, otherwise base64)
Header options
priority - Sets message importance headers, either ‚Äòhigh‚Äô, ‚Äònormal‚Äô (default) or ‚Äòlow‚Äô.
headers - An object or array of additional header fields (e.g. {‚ÄúX-Key-Name‚Äù: ‚Äúkey value‚Äù} or [{key: ‚ÄúX-Key-Name‚Äù, value: ‚Äúval1‚Äù}, {key: ‚ÄúX-Key-Name‚Äù, value: ‚Äúval2‚Äù}]). Read more about custom headers here
messageId - optional Message-Id value, random value will be generated if not set
date - optional Date value, current UTC string will be used if not set
list - helper for setting List-* headers (see more here)
Security options
disableFileAccess if true, then does not allow to use files as content. Use it when you want to use JSON data from untrusted source as the email. If an attachment or message node tries to fetch something from a file the sending returns an error. If this field is also set in the transport options, then the value in mail data is ignored
disableUrlAccess if true, then does not allow to use Urls as content. If this field is also set in the transport options, then the value in mail data is ignored
var message = {
    ...,
    headers: {
        'My-Custom-Header': 'header value'
    },
    date: new Date('2000-01-01 00:00:00')
};
**Memory leak warning!** When using readable streams as content and sending fails then Nodemailer does not abort the already opened but not yet finished stream, you need to do this yourself. Nodemailer only closes the streams it has opened itself (eg. file paths, URLs)
var htmlstream = fs.createReadStream("content.html");
transport.sendMail({ html: htmlstream }, function (err) {
  if (err) {
    // check if htmlstream is still open and close it to clean up
  }
});
AMP example
let message = {
    from: 'Nodemailer <example@nodemailer.com>',
    to: 'Nodemailer <example@nodemailer.com>',
    subject: 'AMP4EMAIL message',
    text: 'For clients with plaintext support only',
    html: '<p>For clients that do not support AMP4EMAIL or amp content is not valid</p>',
    amp: `<!doctype html>
    <html ‚ö°4email>
      <head>
        <meta charset="utf-8">
        <style amp4email-boilerplate>body{visibility:hidden}</style>
        <script async src="https://cdn.ampproject.org/v0.js"></script>
        <script async custom-element="amp-anim" src="https://cdn.ampproject.org/v0/amp-anim-0.1.js"></script>
      </head>
      <body>
        <p>Image: <amp-img src="https://cldup.com/P0b1bUmEet.png" width="16" height="16"/></p>
        <p>GIF (requires "amp-anim" script in header):<br/>
          <amp-anim src="https://cldup.com/D72zpdwI-i.gif" width="500" height="350"/></p>
      </body>
    </html>`
}
Attachments
attachments option in the message object that contains an array of attachment objects.

Attachment object consists of the following properties:

filename - filename to be reported as the name of the attached file. Use of unicode is allowed.
content - String, Buffer or a Stream contents for the attachment
path - path to the file if you want to stream the file instead of including it (better for larger attachments)
href ‚Äì an URL to the file (data uris are allowed as well)
httpHeaders - optional HTTP headers to pass on with the href request, eg. {authorization: "bearer ..."}
contentType - optional content type for the attachment, if not set will be derived from the filename property
contentDisposition - optional content disposition type for the attachment, defaults to ‚Äòattachment‚Äô
cid - optional content id for using inline images in HTML message source
encoding - If set and content is string, then encodes the content to a Buffer using the specified encoding. Example values: ‚Äòbase64‚Äô, ‚Äòhex‚Äô, ‚Äòbinary‚Äô etc. Useful if you want to use binary attachments in a JSON formatted email object.
headers - custom headers for the attachment node. Same usage as with message headers
raw - is an optional special value that overrides entire contents of current mime node including mime headers. Useful if you want to prepare node contents yourself
Attachments can be added as many as you want.

Example

let message = {
    ...
    attachments: [
        {   // utf-8 string as an attachment
            filename: 'text1.txt',
            content: 'hello world!'
        },
        {   // binary buffer as an attachment
            filename: 'text2.txt',
            content: new Buffer('hello world!','utf-8')
        },
        {   // file on disk as an attachment
            filename: 'text3.txt',
            path: '/path/to/file.txt' // stream this file
        },
        {   // filename and content type is derived from path
            path: '/path/to/file.txt'
        },
        {   // stream as an attachment
            filename: 'text4.txt',
            content: fs.createReadStream('file.txt')
        },
        {   // define custom content type for the attachment
            filename: 'text.bin',
            content: 'hello world!',
            contentType: 'text/plain'
        },
        {   // use URL as an attachment
            filename: 'license.txt',
            path: 'https://raw.github.com/nodemailer/nodemailer/master/LICENSE'
        },
        {   // encoded string as an attachment
            filename: 'text1.txt',
            content: 'aGVsbG8gd29ybGQh',
            encoding: 'base64'
        },
        {   // data uri as an attachment
            path: 'data:text/plain;base64,aGVsbG8gd29ybGQ='
        },
        {
            // use pregenerated MIME node
            raw: 'Content-Type: text/plain\r\n' +
                 'Content-Disposition: attachment;\r\n' +
                 '\r\n' +
                 'Hello world!'
        }
    ]
}
Alternatives
In addition to text and HTML, any kind of data can be inserted as an alternative content of the main body - for example a word processing document with the same text as in the HTML field. It is the job of the email client to select and show the best fitting alternative to the reader. Usually this field is used for calendar events and such.

If you want to use a calendar event as the alternative, the consider using the **icalEvent** option instead. See details [here](/message/calendar-events/).
Alternative objects use the same options as attachment objects. The difference between an attachment and an alternative is the fact that attachments are placed into multipart/mixed or multipart/related parts of the message white alternatives are placed into multipart/alternative part.

Usage example:

let message = {
    ...
    html: '<b>Hello world!</b>',
    alternatives: [
        {
            contentType: 'text/x-web-markdown',
            content: '**Hello world!**'
        }
    ]
}
Address object
All email addresses can be plain email addresses

'foobar@example.com'
or with formatted name (includes unicode support)
'–ù–æ–¥–µ –ú–∞–π–ª–µ—Ä <foobar@example.com>'
Notice that all address fields (even *from:*) are comma separated lists, so if you want to use a comma (or any other special symbol) in the name part, make sure you enclose the name in double quotes like this: `'"–ú–∞–π–ª–µ—Ä, –ù–æ–¥–µ" '`
or as an address object (in this case you do not need to worry about the formatting, no need to use quotes etc.)
{
    name: '–ú–∞–π–ª–µ—Ä, –ù–æ–¥–µ',
    address: 'foobar@example.com'
}
All address fields accept values as a comma separated list of emails or an array of emails or an array of comma separated list of emails or address objects - use it as you like. Formatting can be mixed.

...,
to: 'foobar@example.com, "–ù–æ–¥–µ –ú–∞–π–ª–µ—Ä" <bar@example.com>, "Name, User" <baz@example.com>',
cc: [
    'foobar@example.com',
    '"–ù–æ–¥–µ –ú–∞–π–ª–µ—Ä" <bar@example.com>,
    "Name, User" <baz@example.com>'
],
bcc: [
    'foobar@example.com',
    {
        name: '–ú–∞–π–ª–µ—Ä, –ù–æ–¥–µ',
        address: 'foobar@example.com'
    }
]
...
You can even use unicode domains, these are automatically converted to punycode

'"Unicode Domain" <info@m√ºriaad-pol√ºteism.info>'
Calendar events
Calendar events are tricky because different email clients handle these differently. Nodemailer uses the same style as Gmail for attaching calendar files which should ensure maximum compatibility. If you want to attach a calendar event to your email then you can use the message option icalEvent:

icalEvent ‚Äì an object to define calendar event

method ‚Äì optional method, case insensitive, defaults to ‚Äòpublish‚Äô. Other possible values would be ‚Äòrequest‚Äô, ‚Äòreply‚Äô, ‚Äòcancel‚Äô or any other valid calendar method listed in RFC5546. This should match the METHOD: value in calendar event file.
filename ‚Äì optional filename, defaults to ‚Äòinvite.ics‚Äô
content ‚Äì is the event file, it can be a string, a buffer, a stream
path ‚Äì is an alternative for content to load the calendar data from a file
href ‚Äì is an alternative for content to load the calendar data from an URL
encoding ‚Äì defines optional content encoding, eg. ‚Äòbase64‚Äô or ‚Äòhex‚Äô. This only applies if the content is a string. By default an unicode string is assumed.
You can use modules like ical-generator to generate the actual calendar file content, Nodemailer acts as a transport layer only and does not generate the event file structure.

In general it is not a good idea to add additional attachments to calendar messages as it might mess up the behavior of some email clients. Try to keep it only to **text**, **html** and **icalEvent** without any additional **alternatives** or **attachments**
Examples
1. Send a REQUEST event as a string
let content = 'BEGIN:VCALENDAR\r\nPRODID:-//ACME/DesktopCalendar//EN\r\nMETHOD:REQUEST\r\n...';

let message = {
    from: 'sender@example.com',
    to: 'recipient@example.com',
    subject: 'Appointment',
    text: 'Please see the attached appointment',
    icalEvent: {
        filename: 'invitation.ics',
        method: 'request',
        content: content
    }
};
2. Send a PUBLISH event from a file
Event data is loaded from the provided file and attached to the message.

let message = {
    from: 'sender@example.com',
    to: 'recipient@example.com',
    subject: 'Appointment',
    text: 'Please see the attached appointment',
    icalEvent: {
        method: 'PUBLISH',
        path: '/path/to/file'
    }
};
3. Send a CANCEL event from an URL
Event data is downloaded from the provided URL and attached to the message as regular calendar file.

let message = {
    from: 'sender@example.com',
    to: 'recipient@example.com',
    subject: 'Appointment',
    text: 'Please see the attached appointment',
    icalEvent: {
        method: 'CANCEL',
        href: 'http://www.example.com/events?event=123'
    }
};
Embedded images
Attachments can be used as embedded images in the HTML body. To use this feature, you need to set additional property of the attachment - cid (unique identifier of the file) which is a reference to the attachment file. The same cid value must be used as the image URL in HTML (using cid: as the URL protocol, see example below).

**NB!** the cid value should be as unique as possible!
Example
let message = {
    ...
    html: 'Embedded image: <img src="cid:unique@nodemailer.com"/>',
    attachments: [{
        filename: 'image.png',
        path: '/path/to/file',
        cid: 'unique@nodemailer.com' //same cid value as in the html img src
    }]
}
List headers
Nodemailer includes a helper for setting more complex List-* headers with ease. You can use this by providing message option list. It‚Äôs an object where key names are converted into list headers. List key help becomes List-Help header etc.

General rules

If the value is a string, it is treated as an URL
If you want to provide an optional comment, use {url:‚Äòurl‚Äô, comment: ‚Äòcomment‚Äô} object
If you want to have multiple header rows for the same List-* key, use an array as the value for this key
If you want to have multiple URLs for single List-* header row, use an array inside an array
List-* headers are treated as pregenerated values, this means that lines are not folded and strings are not encoded. Use only ascii characters and be prepared for longer header lines
Examples
1. Setup different List-* headers
let message = {
    from: 'sender@example.com',
    to: 'recipient@example.com',
    subject: 'List Message',
    text: 'I hope no-one unsubscribes from this list!',
    list: {
        // List-Help: <mailto:admin@example.com?subject=help>
        help: 'admin@example.com?subject=help',
        // List-Unsubscribe: <http://example.com> (Comment)
        unsubscribe: {
            url: 'http://example.com',
            comment: 'Comment'
        },
        // List-Subscribe: <mailto:admin@example.com?subject=subscribe>
        // List-Subscribe: <http://example.com> (Subscribe)
        subscribe: [
            'admin@example.com?subject=subscribe',
            {
                url: 'http://example.com',
                comment: 'Subscribe'
            }
        ],
        // List-Post: <http://example.com/post>, <mailto:admin@example.com?subject=post> (Post)
        post: [
            [
                'http://example.com/post',
                {
                    url: 'admin@example.com?subject=post',
                    comment: 'Post'
                }
            ]
        ]
    }
};
Custom headers
Most messages do not need any kind of tampering with the headers. If you do need to add custom headers either to the message or to an attachment/alternative, you can add these values with the headers option. Values are processed automatically, non-ascii strings are encoded as mime-words and long lines are folded.

headers ‚Äì is an object of key-value pairs, where key names are converted into message header keys
Examples
1. Set custom headers
let message = {
    ...,
    headers: {
        'x-my-key': 'header value',
        'x-another-key': 'another value'
    }
}

// Becomes:
//   X-My-Key: header value
//   X-Another-Key: another value
2. Multiple rows with the same key
The same header key can be used multiple times if the header value is an Array

let message = {
    ...,
    headers: {
        'x-my-key': [
            'value for row 1',
            'value for row 2',
            'value for row 3'
        ]
    }
}

// X-My-Key: value for row 1
// X-My-Key: value for row 2
// X-My-Key: value for row 3
3. Prepared headers
Normally all headers are encoded and folded to meet the requirement of having plain-ASCII messages with lines no longer than 78 bytes. Sometimes it is preferable to not modify header values and pass these as provided. This can be achieved with the prepared option:

let message = {
    ...,
    headers: {
        'x-processed': 'a really long header or value with non-ascii characters üëÆ',
        'x-unprocessed': {
            prepared: true,
            value: 'a really long header or value with non-ascii characters üëÆ'
        }
    }
}

// X-Processed: a really long header or value with non-ascii characters
//  =?UTF-8?Q?=F0=9F=91=AE?=
// X-Unprocessed: a really long header or value with non-ascii characters ?
Custom source
If you want to use your own custom generated RFC822 formatted message source, instead of letting Nodemailer to generate it from the message options, use option raw. This can be used both for the entire message or alternatively per-attachment or per-alternative.

Don't forget to set the **envelope** option when using **raw** as the message source
Examples
1. Use string as a message body
This example loads the entire message source from a string value. You don‚Äôt have to worry about proper newlines, these are handled by Nodemailer.

let message = {
    envelope: {
        from: 'sender@example.com',
        to: ['recipient@example.com']
    },
    raw: `From: sender@example.com
To: recipient@example.com
Subject: test message

Hello world!`
};
2. Set EML file as message body
This example loads the entire message source from a file

let message = {
    envelope: {
        from: 'sender@example.com',
        to: ['recipient@example.com']
    },
    raw: {
        path: '/path/to/message.eml'
    }
};
3. Set string as attachment body
When using raw for attachments then you need to provide all content headers youself, Nodemailer does not process it in any way (besides newline processing), it is inserted into the MIME tree as is.

let message = {
    from: 'sender@example.com',
    to: 'recipient@example.com',
    subject: 'Custom attachment',
    attachments: [{
        raw: `Content-Type: text/plain
Content-Disposition: attachment

Attached text file`}]
};
